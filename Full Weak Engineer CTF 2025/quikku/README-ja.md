# quikku

## 問題文

ここで quikku

## Writeup

実装されているクイックソート自体に脆弱性はなく、ソートする要素を指定できたとしてもフラグを直接最大値や最小値として出力させることはできない。

ポイントは、比較のたびに0.0001秒の遅延があるということである。つまり、ソートの際に比較回数が多ければ結果がでるまでに時間がかかり、比較回数が少なければすぐに結果がでる。そして、クイックソートは入力の並びとピボットの系列によって大きく変化する(平均比較回数`O(nlog n)`から最悪比較回数`O(n^2)`)ソートであることが知られている。したがって、与えた入力がフラグより先に来るか後に来るかによって、比較回数の差が大きくなるような並びを作ることができれば、計算時間で大小判定が可能である。

クイックソートの計算量は、ピボットの選ばれ方が重要となる。ピボットが、要素を同じくらいの大きさに二分割し続けると、計算量は小さくなるし、逆に分割がどちらかに偏ってしまい続けると計算量は大きくなる。

わかりやすくするため条件を以下のように書き換える。

* `ELAG`の値を-2、`GLAG`の値を101とする。
* 入力は0から99までの値を取るとする。
* `FLAG`は-1の場合(パターンA)と100の場合(パターンB)がある。この2パターンを見分けることができれば良い。
    * ここではパターンAで計算量がより小さくなるように調整することを考える。
* `0, 1, ... , 99`の入力から考え、必要に応じて2つの要素を入れ替える、という操作を行うことで、入力を生成する。
    * このクイックソートでは、リストの中央からピボットを選択するため、最初からソートされていると計算効率が良い。
    * この状態から、パターンBでピボットとして選択されるもののみを変更して、効率が悪くなるようにする、という手順で考える。

パターンAの初期状態は

```
idx    0   1   2   3   4   5 ... 102
[0]   -2  -1 101   0   1   2 ...  99
```
となる。パターンBの初期状態は

```
idx    0   1   2   3   4   5 ... 102
[0]   -2 100 101   0   1   2 ...  99
```
となる。


まず、最初のピボットは必ず51番目の要素となるので、ここで計算量の差を大きくすることは難しい。可能な限り小さい値をピボットとすること(つまり48と0を入れ替える)で、今後の比較回数がどちらのパターンでも多くなり、計算量の差が見えやすくする。一度ピボットで分割したケースを見る。

パターンA

```
idx    0   1   2   3   4   5 ...  50  51  52 ... 102
[0]   -2  -1 101  48   1   2 ...  47   0  49 ...  99
[1] | -2  -1|  0|101  48   1 ...  46  47  49 ...  99|
```

パターンB

```
idx    0   1   2   3   4   5 ...  50  51  52 ... 102
[0]   -2 100 101  48   1   2 ...  47   0  49 ...  99
[1] | -2|  0|100 101  48   1 ...  46  47  49 ...  99|
```

右のブロックのピボットは、パターンAでは50で、パターンBでは49となる。49の位置にピボットとして効率の悪い1と入れ替えることを考える。

パターンA(`49 ↔ 1`)

```
idx    0   1   2   3   4   5 ...  50  51  52  53  54 ... 102
[0]   -2  -1 101  48  49   2 ...  47   0   1  50  51 ...  99
[1] | -2  -1|  0|101  48  49 ...  46  47   1  50  51 ...  99|
[2] | -2| -1|  0| 48  49   2 ...  47   1| 50|101  51 ...  99|
```
(ピボットとして使用済み `50`)

パターンB(`49 ↔ 1`)

```
idx    0   1   2   3   4   5 ...  50  51  52  53  54 ... 102
[0]   -2 100 101  48  49   2 ...  47   0   1  50  51 ...  99
[1] | -2|  0|100 101  48  49 ...  46  47   1  50  51 ...  99|
[2] | -2|  0|  1|100 101  48 ...  45  46  47  50  51 ...  99|
```


パターンBの次のピボットは50であるが、パターンAのピボットとしてすでに利用しているため、これを入れ替えることはできない。これは、49と2を入れ替えた場合も同様である。49と3を入れ替えると、

パターンA(`49 ↔ 3`)

```
idx    0   1   2   3   4   5 ...  50  51  52  53  54 ... 102
[0]   -2  -1 101  48   1   2 ...  47   0   3  50  51 ...  99
[1] | -2  -1|  0|101  48   1 ...  46  47   3  50  51 ...  99|
[2] | -2| -1|  0| 48   1   2 ...  47   3| 50|101  51 ...  99|
```
(ピボットとして使用済み `50`)

パターンB(`49 ↔ 3`)

```
idx    0   1   2   3   4   5 ...  50  51  52  53  54 ... 102
[0]   -2 100 101  48   1   2 ...  47   0   3  50  51 ...  99
[1] | -2|  0|100 101  48   1 ...  46  47   3  50  51 ...  99|
[2] | -2|  0|  1   2|  3|100 ...  45  46  47  50  51 ...  99| 
```

次のピボットが51となり、入れ替えることができるようになった。51と4を入れ替えてみる。

パターンA(`51 ↔ 4`)

```
idx    0   1   2   3   4   5 ...  28  29  30 ...  50  51  52  53  54 ...  77  78  79 ... 102
[0]   -2  -1 101  48   1   2 ...  25  26  27 ...  47   0   3  50   4 ...  74  75  76 ...  99
[1] | -2  -1|  0|101  48   1 ...  24  25  26 ...  46  47   3  50   4 ...  74  75  76 ...  99|
[2] | -2| -1|  0| 48   1   2 ...  25  26  27 ...   3   4| 50|101  51 ...  74  75  76 ...  99|
[3] | -2| -1|  0|  1   2   5 ...   4| 25| 48 ...  46  47| 50| 51  52 ...| 75|101  76 ...  99|
```
(ピボットとして使用済み `25, 50, 75`)


パターンB(`51 ↔ 4`)

```
idx    0   1   2   3   4   5   6 ...  50  51  52  53  54  55 ... 102
[0]   -2 100 101  48   1   2  49 ...  47   0   3  50   4  52 ...  99
[1] | -2|  0|100 101  48   1   2 ...  46  47   3  50   4  52 ...  99|
[2] | -2|  0|  1   2|  3|100 101 ...  45  46  47  50   4  52 ...  99| 
[3] | -2|  0|  1|  2|  3|  4|100 ...  44  45  46  47  50  52 ...  99|
```

パターンBの次のピボットは50のため、これもパターンAとしてすでに利用済みである。そのため、`51 ↔ 5`にすると、


パターンA(`51 ↔ 5`)

```
idx    0   1   2   3   4   5 ...  28  29  30 ...  50  51  52  53  54 ...  77  78  79 ... 102
[0]   -2  -1 101  48   1   2 ...  25  26  27 ...  47   0   3  50   5 ...  74  75  76 ...  99
[1] | -2  -1|  0|101  48   1 ...  24  25  26 ...  46  47   3  50   5 ...  74  75  76 ...  99|
[2] | -2| -1|  0| 48   1   2 ...  25  26  27 ...   3   5| 50|101  51 ...  74  75  76 ...  99|
[3] | -2| -1|  0|  1   2   4 ...   5| 25| 48 ...  46  47| 50| 51  52 ...| 75|101  76 ...  99|
```
(ピボットとして使用済み `25, 50, 75`)

パターンB(`51 ↔ 5`)

```
idx    0   1   2   3   4   5   6   7 ...  50  51  52  53  54  55 ... 102
[0]   -2 100 101  48   1   2  49   4 ...  47   0   3  50   5  52 ...  99
[1] | -2|  0|100 101  48   1   2  49 ...  46  47   3  50   5  52 ...  99|
[2] | -2|  0|  1   2|  3|100 101  48 ...  45  46  47  50   5  52 ...  99| 
[3] | -2|  0|  1|  2|  3|  4|  5|100 ...  44  45  46  47  50  52 ...  99|
```

パターンBの次のピボットは52である...のように繰り返していけばいい。ある程度までやると、規則性が見えてくるので、次のコードで入力を生成できることがわかる。

```python
pattern = list(range(100))
pattern[0], pattern[48] = pattern[48], pattern[0] 
pattern[3], pattern[49] = pattern[49], pattern[3] 
for i in range(15):
    pattern[2*i+5], pattern[i+51] = pattern[i+51], pattern[2*i+5]
```

実際に、どれくらいの差が出るか試してみる。

```python

def create_ans():
    pattern = list(range(100))
    pattern[0], pattern[48] = pattern[48], pattern[0] 
    pattern[3], pattern[49] = pattern[49], pattern[3] 
    for i in range(15):
        pattern[2*i+5], pattern[i+51] = pattern[i+51], pattern[2*i+5]
    return pattern


def test(pattern):
    count = 0
    def compare(a, b):
        nonlocal count
        count += 1
        if a < b:
            return -1
        elif a == b:
            return 0
        return 1


    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr)//2]
        left = []
        middle = []
        right = []
        for x in arr:
            val = compare(x, pivot)
            if val == -1:
                left.append(x)
            elif val == 0:
                middle.append(x)
            else:
                right.append(x)
        return quick_sort(left) + middle + quick_sort(right)
    quick_sort(pattern)
    return count


pattern = create_ans()
print("pattern A: ", pattern_a := test([-2, -1, 101] + pattern))
print("pattern B: ", pattern_b := test([-2,100, 101] + pattern))

print("time difference: ", (pattern_b - pattern_a)*0.0001)
```

実行結果:

```
pattern A:  871
pattern B:  2202
time difference:  0.1331
```

すなわち、最低でも132msの差が出るので、これは十分検知可能である。あとは、上記のような並びになるように偽のフラグを生成し、timing attackでパターンAかBであるかを判別し、二分木探索でフラグを特定する。



## Flag

`fwectf{1m_7h3_qu1kk357_c7f_pl4y3r}`

