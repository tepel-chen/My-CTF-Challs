

## 問題文

このマシン、めっちゃ便利〜〜！

**注: フラグのフォーマットは `Alpaca{[\x20-\x7E]+}` です。**

## Writeup

### 

このプログラムでは単純な仮想マシンを実装しています。各オペコードは1バイトで表現されており、その後にそれぞれ1バイトの2つのオペランドが続きます。

すべての操作は256での剰余で実行されますが、以下のコード中では省略されています。

|オペコード|表現|説明|コード|
|---|---|---|---|
|0|`INP`|入力から1バイトを読み込み、メモリに保存する|`mem[operand1] = input`|
|1|`MOV`(即値)|即値をメモリに移動する|`mem[operand1] = operand2`|
|2|`MOV`(参照)|あるメモリの値を別のメモリにコピーする|`mem[operand1] = mem[operand2]`|
|3|`ADD`|2つのメモリ値を加算し、その結果を保存する|`mem[operand1] = mem[operand1] + mem[operand2]`|
|4|`MUL`|2つのメモリ値を乗算し、その結果を保存する|`mem[operand1] = mem[operand1] * mem[operand2]`|
|5|`XOR`|2つのメモリ値をXORし、その結果を保存する|`mem[operand1] = mem[operand1] ^ mem[operand2]`|
|6|`NOT`|メモリ値が0であれば1に、そうでなければ0に設定する|`mem[operand1] = 0 if mem[operand1] != 0 else 1`|

このチャレンジでは、与えられたプログラムにおいて`mem[0] == 0`となる入力を見つけることが目的となります。

### 解法1: 逆アセンブラの作成

汎用的な解法の一つは、自分で逆アセンブラを作成することです。具体的には、[実装例](./solution/disassembler.py)を参考にしてください。すると、以下のコードが繰り返し現れていることに気付くでしょう。

```
INP	mem[1]
ADD	mem[1]	mem[3]
MOV	mem[2]	<v1>
XOR	mem[1]	mem[2]
MOV	mem[3]	mem[1]
MOV	mem[2]	<v2>
ADD	mem[1]	mem[2]
NOT	mem[1]
MUL	mem[0]	mem[1]
```

最後の命令が`NOT mem[0]`であるため、`mem[0]`は非ゼロであってほしいことになります。これはつまり、`NOT mem[1]`の直前で`mem[1]`が0でなければならない、ということを意味します。

この処理を疑似コードで書くと、次のようになります。

```
val = (input + prev) % 256 # prevの初期値は0
val = val ^ v1
prev = val
val = (val + v2) % 256 # ここでvalは0でなければならない
```

言い換えると、

```
((v1 ^ (input + prev) % 256) + v2) % 256
```

が0でなければなりません。この式を逆算することで、入力は次の値である必要があると分かります。

```
((256 - v2) ^ v1 - prev) % 256
```

この方法により、フラグ全体を復元できます。完全なソルバーについては[`solver1.py`](./solution/solver1.py)を参照してください。

### 解法2: 動的解析

完全な逆アセンブラを作成する代わりに、VMの実行中にいくつかの情報を出力して、どのように動作しているかを理解することもできます。この場合、正しい入力を与えた場合、`mem[0]`が非ゼロである状態がより長く続くことが分かるでしょう。
そのため、各文字をブルートフォースし、`mem[0]`が`0`になるまでに何ステップかかるかを見ることで、その文字が正しいかを判別することができます。

完全なソルバーについては[`solver2.py`](./solution/solver2.py)を参照してください。

## フラグ


`Alpaca{Futures_Made_of_Virtual_Machines}` [動画](https://youtu.be/4JkIs37a2JE)
